<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Snake — Stages (Score Targets)</title>
<style>
:root{
  --bg:#071428; --card:#071a2a; --accent:#00d4ff; --muted:#9aa7b2; --glass:rgba(255,255,255,0.03);
  --radius:12px; font-family: Inter, system-ui, -apple-system, Arial;
}
*{box-sizing:border-box} body{margin:0;height:100vh;background:linear-gradient(180deg,#04101a,#071428);display:flex;align-items:center;justify-content:center;color:#e6f0f6;padding:20px}
.container{width:100%;max-width:1100px;display:grid;grid-template-columns:1fr 340px;gap:20px}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:var(--radius);padding:16px;box-shadow:0 8px 30px rgba(2,8,23,0.6);border:1px solid rgba(255,255,255,0.03)}
.canvas-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
canvas{background:linear-gradient(180deg,#071a2a,#04101a);border-radius:10px;box-shadow: inset 0 2px 8px rgba(255,255,255,0.02); image-rendering: pixelated}
.hud{display:flex;gap:10px;align-items:center;justify-content:space-between;width:100%}
.chips{display:flex;gap:8px;align-items:center}
.chip{background:var(--glass);padding:8px 10px;border-radius:10px;font-weight:700;color:var(--muted);min-width:88px;text-align:center}
.score{color:var(--accent);font-size:18px}
.controls{display:flex;flex-direction:column;gap:12px}
.row{display:flex;gap:8px;align-items:center}
.btn{padding:9px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#dff6ff;font-weight:700;cursor:pointer}
.btn.primary{background:linear-gradient(90deg,var(--accent),#2fe0b2);color:#02121a}
.small{font-size:13px;color:var(--muted)}
.range{flex:1}
.touch-grid{display:grid;grid-template-columns:repeat(3,48px);gap:8px;justify-content:center}
.progress-wrap{background:rgba(255,255,255,0.03);border-radius:8px;padding:6px}
.progress{height:12px;border-radius:6px;background:linear-gradient(90deg,#11353f,#072b35);overflow:hidden}
.progress > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#2fe0b2)}
.centered-overlay{position:absolute;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}
.modal{background:rgba(2,8,23,0.7);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);text-align:center}
.stage-badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;font-weight:800;color:var(--accent)}
footer.small{color:var(--muted);text-align:center;margin-top:6px}
@media (max-width:960px){.container{grid-template-columns:1fr;max-width:700px}}
</style>
</head>
<body>
<div class="container">
  <div class="card" style="position:relative">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h2 style="margin:0">Snake — Stage Targets</h2>
        <div class="small">Reach the target score to clear a stage. Progress updates in real time.</div>
      </div>
      <div class="stage-badge" id="stageLabel">Stage 1</div>
    </div>

    <div class="canvas-wrap" style="margin-top:12px">
      <canvas id="board" width="760" height="460"></canvas>
      <div class="hud" style="width:100%;max-width:820px">
        <div class="chips">
          <div class="chip">Score<div class="score" id="score">0</div></div>
          <div class="chip">High<div class="score" id="high">0</div></div>
          <div class="chip">Length<div id="len" style="font-weight:800">1</div></div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn primary" id="start">Start</button>
          <button class="btn" id="pause">Pause</button>
          <button class="btn" id="reset">Reset</button>
        </div>
      </div>

      <div style="width:100%;max-width:820px;margin-top:10px">
        <div class="small">Stage Target: <span id="targetLabel">30</span> pts</div>
        <div class="progress-wrap" style="margin-top:6px">
          <div class="progress"><i id="progressBar"></i></div>
        </div>
      </div>
    </div>

    <!-- Stage modal overlay -->
    <div id="modal" class="centered-overlay" style="display:none">
      <div class="modal">
        <h3 id="modalTitle">Stage Complete</h3>
        <p id="modalMsg" class="small" style="margin:6px 0">Great! Moving to next stage...</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
          <button class="btn" id="modalContinue">Continue</button>
        </div>
      </div>
    </div>
  </div>

  <aside class="card controls">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h3 style="margin:0">Settings</h3>
        <div class="small">Adjust speed and grid. Stage targets are fixed below.</div>
      </div>
    </div>

    <div class="row">
      <div class="small">Speed</div>
      <input id="speed" class="range" type="range" min="1" max="20" value="8">
      <div class="small" id="speedVal">8</div>
    </div>

    <div class="row">
      <div class="small">Grid</div>
      <select id="grid" class="btn" style="padding:8px 10px">
        <option value="16">16 px</option><option value="20" selected>20 px</option><option value="24">24 px</option>
      </select>
    </div>

    <div>
      <div class="small" style="margin-bottom:6px">Stage List</div>
      <ol id="stageList" style="margin:0 0 6px 18px;color:var(--muted)"></ol>
      <div class="small">When you reach the target (score), the next stage starts automatically. Good luck!</div>
    </div>

    <div style="margin-top:6px">
      <div class="small">Touch Controls</div>
      <div class="touch-grid" id="touch">
        <button class="btn" data-dir="up">▲</button>
        <button class="btn" data-dir="left">◀</button>
        <button class="btn" data-dir="right">▶</button>
        <div style="grid-column:1/span3;text-align:center;color:var(--muted);font-size:12px">Tap to move</div>
        <button class="btn" data-dir="down">▼</button>
      </div>
    </div>

    <footer class="small">Made with ♥ — Stage mode (Score Targets)</footer>
  </aside>
</div>

<script>
(() => {
  const canvas = document.getElementById('board'), ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score'), highEl = document.getElementById('high'), lenEl = document.getElementById('len');
  const startBtn = document.getElementById('start'), pauseBtn = document.getElementById('pause'), resetBtn = document.getElementById('reset');
  const speedInput = document.getElementById('speed'), speedVal = document.getElementById('speedVal'), gridSel = document.getElementById('grid');
  const stageLabel = document.getElementById('stageLabel'), targetLabel = document.getElementById('targetLabel'), progressBar = document.getElementById('progressBar');
  const modal = document.getElementById('modal'), modalTitle = document.getElementById('modalTitle'), modalContinue = document.getElementById('modalContinue');
  const stageListEl = document.getElementById('stageList'), touch = document.getElementById('touch');

  // STAGES: score targets (you can change/extend this array)
  const STAGES = [
    { name: 'Stage 1', target: 30 },
    { name: 'Stage 2', target: 80 },
    { name: 'Stage 3', target: 150 },
    { name: 'Stage 4', target: 260 },
    { name: 'Final', target: 420 }
  ];

  // show stages in sidebar
  stageListEl.innerHTML = STAGES.map((s,i)=>`<li style="margin-bottom:6px">${s.name} — ${s.target} pts</li>`).join('');

  // state
  let GRID = parseInt(gridSel.value,10);
  let cols = Math.floor(canvas.width/GRID), rows = Math.floor(canvas.height/GRID);
  let snake = [{x:Math.floor(cols/2), y:Math.floor(rows/2)}];
  let dir = {x:1,y:0}, nextDir = null;
  let food = null;
  let score = 0, high = parseInt(localStorage.getItem('snakeHigh')||'0',10) || 0;
  let running=false, paused=false;
  let speed = parseInt(speedInput.value,10);
  let tickTimer = null;

  // stage
  let stageIndex = 0; // current stage index
  let stageBaseSpeedBoost = 0; // increases slightly each stage

  highEl.textContent = high;

  function speedToInterval(s){
    const min = 40, max = 260;
    const base = Math.round(max - ((s-1)/19)*(max-min));
    // apply small stage speed boost (higher stage -> slightly faster)
    return Math.max(20, Math.round(base - stageBaseSpeedBoost));
  }

  function spawnFood(){
    let tries=0, ok=false;
    while(!ok && tries<400){
      const fx = Math.floor(Math.random()*cols), fy = Math.floor(Math.random()*rows);
      if(!snake.some(p=>p.x===fx && p.y===fy)){
        food={x:fx,y:fy}; ok=true;
      }
      tries++;
    }
    if(!ok) food=null;
  }

  function reset(full=false){
    GRID = parseInt(gridSel.value,10);
    cols = Math.floor(canvas.width/GRID); rows = Math.floor(canvas.height/GRID);
    snake = [{x:Math.floor(cols/2), y:Math.floor(rows/2)}];
    dir = {x:1,y:0}; nextDir=null;
    score = 0; scoreEl.textContent = score; lenEl.textContent = snake.length;
    if(full){ stageIndex = 0; stageBaseSpeedBoost = 0; }
    updateStageUI();
    spawnFood(); draw();
  }

  function updateStageUI(){
    const st = STAGES[stageIndex];
    stageLabel.textContent = st.name;
    targetLabel.textContent = st.target;
    const pct = Math.min(100, Math.round((score / st.target)*100));
    progressBar.style.width = pct + '%';
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // subtle grid dots
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    for(let x=0;x<cols;x++) for(let y=0;y<rows;y++) if((x+y)%8===0) ctx.fillRect(x*GRID+0.5,y*GRID+0.5,1,1);

    // food
    if(food){
      const fx = food.x*GRID, fy = food.y*GRID;
      ctx.beginPath();
      ctx.arc(fx+GRID/2, fy+GRID/2, GRID*0.36, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,110,110,0.95)'; ctx.fill();
    }

    // snake
    snake.forEach((s,i)=>{
      const x = s.x*GRID, y = s.y*GRID;
      const t = i/(snake.length-1||1);
      const r = Math.round(0 + 0*t), g = Math.round(200+55*(1-t)), b = Math.round(255-120*t);
      ctx.fillStyle = `rgba(${r},${g},${b},1)`;
      roundRect(ctx, x+1, y+1, GRID-2, GRID-2, GRID*0.18); ctx.fill();
      if(i===0){ ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=1; ctx.stroke(); }
    });

    // border
    ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1; ctx.strokeRect(0.5,0.5,cols*GRID-1, rows*GRID-1);
  }

  function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); c.closePath(); }

  function scheduleTick(){
    if(!running || paused) return;
    if(tickTimer) clearTimeout(tickTimer);
    tickTimer = setTimeout(()=>{ gameTick(); scheduleTick(); }, speedToInterval(speed));
  }

  function start(){ if(running && !paused) return; running=true; paused=false; pauseBtn.textContent='Pause'; scheduleTick(); }
  function pause(){ if(!running) return; paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; if(!paused) scheduleTick(); else { if(tickTimer) clearTimeout(tickTimer); } }
  function stop(){ running=false; paused=false; if(tickTimer) clearTimeout(tickTimer); }

  function nextStage(){
    // small boost each stage to base speed effect
    stageBaseSpeedBoost += 14;
    stageIndex = Math.min(STAGES.length-1, stageIndex+1);
    // keep score (so progress to next stage is continued)
    updateStageUI();
    showModal(`${STAGES[stageIndex-1].name} cleared!`, `Now entering ${STAGES[stageIndex].name}`);
    // continue automatically after brief pause
    setTimeout(()=>{ hideModal(); }, 900);
  }

  function showModal(title, msg){
    modalTitle.textContent = title;
    document.getElementById('modalMsg').textContent = msg;
    modal.style.display = 'flex';
  }
  function hideModal(){ modal.style.display = 'none'; }

  function gameTick(){
    if(nextDir){ if(!(nextDir.x===-dir.x && nextDir.y===-dir.y)) dir = nextDir; nextDir=null; }

    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    // wrap edges
    head.x = (head.x + cols) % cols; head.y = (head.y + rows) % rows;

    // self-collision
    if(snake.some((s,idx)=> idx!==0 && s.x===head.x && s.y===head.y)){ gameOver(); return; }

    snake.unshift(head);

    // eat
    if(food && head.x===food.x && head.y===food.y){
      score += 10;
      scoreEl.textContent = score;
      spawnFood();
    } else { snake.pop(); }

    lenEl.textContent = snake.length;
    if(score > high){ high = score; localStorage.setItem('snakeHigh', String(high)); highEl.textContent = high; }

    // stage progression check
    const currentTarget = STAGES[stageIndex].target;
    if(score >= currentTarget){
      // if final stage already reached and score >= final target, show victory
      if(stageIndex >= STAGES.length-1){
        stop();
        showModal('Congratulations!', `You cleared the final stage with ${score} pts`);
      } else {
        nextStage();
      }
    }

    updateStageUI();
    draw();
  }

  function gameOver(){
    stop();
    setTimeout(()=>{ alert('Game Over — Score: ' + score); reset(false); }, 80);
  }

  // inputs
  window.addEventListener('keydown', e=>{
    if(['ArrowUp','w','W'].includes(e.key)) setDir(0,-1);
    if(['ArrowDown','s','S'].includes(e.key)) setDir(0,1);
    if(['ArrowLeft','a','A'].includes(e.key)) setDir(-1,0);
    if(['ArrowRight','d','D'].includes(e.key)) setDir(1,0);
    if(e.key === ' '){ if(!running) start(); else pause(); }
    if(e.key === 'r' || e.key === 'R') reset(true);
  });

  function setDir(x,y){ const cand = {x,y}; if(dir.x === -cand.x && dir.y === -cand.y) return; nextDir = cand; }

  touch.addEventListener('click', (ev)=>{
    const b = ev.target.closest('button[data-dir]'); if(!b) return;
    const d = b.getAttribute('data-dir'); if(d==='up') setDir(0,-1); if(d==='down') setDir(0,1); if(d==='left') setDir(-1,0); if(d==='right') setDir(1,0);
  });

  startBtn.addEventListener('click', ()=> start());
  pauseBtn.addEventListener('click', ()=> pause());
  resetBtn.addEventListener('click', ()=> reset(true));
  modalContinue.addEventListener('click', ()=> hideModal());

  speedInput.addEventListener('input', ()=>{ speed = parseInt(speedInput.value,10); speedVal.textContent = speed; if(running && !paused) scheduleTick(); });
  gridSel.addEventListener('change', ()=> reset(true));

  // initial
  spawnFood();
  reset(true);
  draw();

  // expose for dev
  window.SnakeStages = { reset, start, pause, getState: ()=>({score, stageIndex}) };
})();
</script>
</body>
</html>
